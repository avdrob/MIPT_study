;*************************************************
; SAV_STR2.ASM     Version 2.0    12/19/90 10:53pm (c) Ded
;*************************************************
my_program segment                      ; Сегмент исполняемого кода программы
assume cs: my_program, ds: my_program   ; CS, DS указывают на my_program
org 100h                                ; Начало исполняемого кода с CS:100h
;-------------------------------------------------
	backsp    equ 8     		; ASCII код обратного клавиша
	end_line  equ 13                ; ASCII код возврата каретки
	KING_SIZE equ 20                ; НАШ размер...
	BUF_SIZE  equ KING_SIZE         ; Размер буфера
;=================================================
start:	                                ; Начало программы
	mov ah, 09h                     ; Печатаем приглашение
	lea dx, start_mess              ;
	int 21h                         ;
	lea bx, buffer                  ; В BX - начало буфера

next:	mov ah, 0                       ; Прерывание 16, функция 0 - ожидать
	int 16h                         ; нажатие клавиши и вернуть код в AL
	cmp al, backsp                  ; Забой?
	je back                         ; Да - обрабатываем
	cmp al, end_line                ; Нет; Возврат каретки?
	je done                         ; Да - обрабатываем
					; Нет; Значит, просто символ. 
	cmp bx, offset buffer + BUF_SIZE; Превышена ли длина буфера?                            
					;
	jae beep                        ; Да - переполнение. Уходим на писк
	mov [bx], al                    ; Нет; Пихаем символ в буфер
	inc bx                          ; Увеличиваем динамическую длину буфера
	mov ah, 02h                     ; Выдаем символ на экран
	mov dl, al                      ;
	int 21h                         ;
	jmp next                        ; И начинаем ввод снова.

back:                                   ; Нажата обратная клавиша!!!
	cmp bx, offset buffer           ; А не находимся ли мы в начале буфера?
	je next                         ; Да - стирание невозможно
	mov ah, 09h                     ; Нет - выдаем на экран стирающую
	lea dx, clear                   ; последовательность
	int 21h                         ;
	dec bx                          ; Уменьшаем динам. длину буфера
	mov byte ptr [bx], '$'          ; Забиваем букву в буфере
	jmp next                        ; На следующую букву

beep:	mov ah, 02h                     ; Пищим с помощью ДОСа
	mov dl, 7                       ;
	int 21h                         ;
	jmp next                        ; На следующую букву 

done:                                   ; Нажат возврат каретки.
	cmp bx, offset buffer           ; Есть ли что-нибудь в буфере?
	je noth                         ; Нет - особый случай
	mov ah, 09h                     ; Буфер не пуст: выводим сообщение,
	lea dx, message                 ;
	int 21h                         ;
	lea dx, buffer                  ; печатаем содержимое буфера.
	int 21h                         ;
	jmp exit                        ; Заканчиваем работу

noth:	mov ah, 09h                     ; Пустая строка. Выводим соответ-                             
					; ствующее сообщение и пищим 1 сек.
	lea dx, mess_noth               ; адрес строки для вывода                             
	int 21h                         ; просим ДОС вывести строку                             

exit:	mov ax, 4c00h             ; Выходим из программы с кодом выхода 0
	int 21h                   ; Выходим...

	buffer  db BUF_SIZE dup ('$'), '$'            ; Буфер для ввода.
	message db 13,10, 'You have typed:',13,10,'$' ; Сообщения для вывода
						      ; на экран ('$' - признак
	start_mess db 'Copyright (c) Ded, 1990. '     ; конца (Хм...) строки
		   db 'Welcome to MY input!', 13,10
		   db 'Type some letters and press ENTER.'
		   db 13,10, '$'
	mess_noth  db 'You typed nothing!', '$'
	clear      db 8, ' ', 8, '$'                  ; 
;==================================================
my_program ends                   ; Конец (Хм...) сегмента
;**************************************************
end start                         ; Исполняемый код начинается с метки start
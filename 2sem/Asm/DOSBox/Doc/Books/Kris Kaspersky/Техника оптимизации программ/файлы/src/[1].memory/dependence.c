/* ---------------------------------------------------------------------------
 * @
 *				УТИЛИТА ДЛЯ ИЗМЕРЕНИЯ ПРОПУСКНОЙ СПОСОБНОСТИ
 *		оперативной памяти при чтении зависимых и независимых данных
 *		============================================================
 *
 * Build 0x003	12.06.2002
 * Build 0x002	16.05.2002
--------------------------------------------------------------------------- */

// КОНФИГУРАЦИЯ
// ============
#define BLOCK_SIZE (16*M)					// Размер обрабатываемого блока


#include <DoCPU.h>

main()
{
	int a;
	int x=0;
	int *p1, *p2;

	// выделение обрабатываемых блоков памятим
	p1 = malloc(BLOCK_SIZE);
	p2 = malloc(BLOCK_SIZE);
	
	// TITLE
	PRINT("=== демонстрация эффективности обработки независимых данных ===\n");
	PRINT_TITLE;
	PRINT("------------------ Тестирование ------------------\n");

	/* -----------------------------------------------------------------------
	 *
	 *		Измерение пропускной способности при чтении зависимых данных
	 *
	----------------------------------------------------------------------- */

	// Заполняем память нулями, т.к. нам необходимо использовать считанные
	// данные для косвенной адресации.
	memset(p1, 0, BLOCK_SIZE);
	CLEAR_L2_CACHE();

	A_BEGIN(0)
		// Разворачиваем цикл для коменсацации латентности CPU
		for (a=0; a < BLOCK_SIZE; a += 8 * sizeof(int))
		{
			// Читаем ячейку
			x = *(int *)((char *)p1 + a + 0 * sizeof(int));

			// Адрес следующей ячейки вычисляется на основе значения предыдущей
			// поэтому, процессор не может посылать запрос чипсету до тех пор,
			// пока не получит эту ячейку в свое распоряжение
			a += x;

			// Дальше - аналогично...
			x = *(int *)((char *)p1 + a + 1 * sizeof(int));
			a += x;
			x = *(int *)((char *)p1 + a + 2 * sizeof(int));
			a += x;
			x = *(int *)((char *)p1 + a + 3 * sizeof(int));
			a += x;
			x = *(int *)((char *)p1 + a + 4 * sizeof(int));
			a += x;
			x = *(int *)((char *)p1 + a + 5 * sizeof(int));
			a += x;
			x = *(int *)((char *)p1 + a + 6 * sizeof(int));
			a += x;
			x = *(int *)((char *)p1 + a + 7 * sizeof(int));
			a += x;
		}
	A_END(0)
	printf("%s:\t %4.2f (Mbytes/s)\n",		/* вывод результов на экран */
	_TEXT("Чтение зависимых   данных"), ((BLOCK_SIZE)/cpu2time(Ax_GET(0))));

	/* -----------------------------------------------------------------------
	 *
	 *	Измерение пропускной способности при чтении _не_зависимых данных
	 *
	----------------------------------------------------------------------- */
	CLEAR_L2_CACHE();

	A_BEGIN(1)
		for (a=0; a < BLOCK_SIZE; a += 8 * sizeof(int))
		{
			// Теперь процессор может подавать следующий запрос на чтение
			// не дожидаясь завершения предыдущего, поскольку его адрес
			// никак не связан с обрабатываемыми данными
			x += *(int *)((char *)p2 + a + 0 * sizeof(int));
			x += *(int *)((char *)p2 + a + 1 * sizeof(int));
			x += *(int *)((char *)p2 + a + 2 * sizeof(int));
			x += *(int *)((char *)p2 + a + 3 * sizeof(int));
			x += *(int *)((char *)p2 + a + 4 * sizeof(int));
			x += *(int *)((char *)p2 + a + 5 * sizeof(int));
			x += *(int *)((char *)p2 + a + 6 * sizeof(int));
			x += *(int *)((char *)p2 + a + 7 * sizeof(int));
		}
	A_END(1)

	// вывод результатов на консоль
	printf("%s:\t %4.2f (Mbytes/s)\n",		/* вывод результов на экран */
	_TEXT("Чтение независимых данных"),((BLOCK_SIZE)/cpu2time(Ax_GET(1))));


	PRINT(_TEXT("--------------------------------------------------\n"));
return x;

}
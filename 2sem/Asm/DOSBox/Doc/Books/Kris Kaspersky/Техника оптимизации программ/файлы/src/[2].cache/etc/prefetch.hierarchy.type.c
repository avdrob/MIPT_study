/*----------------------------------------------------------------------------
 *
 *					ПРИМЕР ДЕМОНСТРИРУЮЩИЙ ВЛИЯЕНИЕ ВЫБОРА
 *				ПРЕДВЫБИРАЕМОЙ КЭШ-ИЕРАРХИИ НА ПРОИЗВОДИТЕЛЬНОСТЬ
 *				=================================================
 *
 * Build 0x002 10.08.2002
----------------------------------------------------------------------------*/
#define BLOCK_SIZE	(4*M)
#define STEP_SIZE	32

//#include <math.h> 
#include <DoCPU.h>
#include <DoCPU.cmd.h>

/*----------------------------------------------------------------------------
 *
 *						ТЕСТ БЕЗ ПРЕДВЫБОРКИ
 *										(неоптимизированный вариант)
 *
----------------------------------------------------------------------------*/
int no_prefetch(int *p)
{
	int a;
	int x = 0;

	for(a = 0; a < BLOCK_SIZE; a += STEP_SIZE)
	{
		// делаем некоторые вычисления (какие - не важно)
		x += a/(a+1);
	
		// считываем очередную порцию ячеек
		x += *(int *)((char *)p + a + 0);
		x += *(int *)((char *)p + a + 4);
		x += *(int *)((char *)p + a + 8);
		x += *(int *)((char *)p + a + 12);
		x += *(int *)((char *)p + a + 16);
		x += *(int *)((char *)p + a + 20);
		x += *(int *)((char *)p + a + 24);
		x += *(int *)((char *)p + a + 28);
	}
return x;
}

/*----------------------------------------------------------------------------
 *
 *						ТЕСТ C ПРЕДВЫБОРКОЙ prefetchnta
 *								mem -> L1
 *
----------------------------------------------------------------------------*/
int have_prefetchnta(int *p)
{
	int a;
	int x = 0;

	for(a = 0; a < BLOCK_SIZE; a += STEP_SIZE)
	{
		// даем команду на предвыборку следующей кэш-строки в L1-кэш
		// она будет загружается параллельно с выполнением вычислений a/(a+1)
		// и, когда соотвествующая ячейка станет затребована, она уже
		// окажется в кэше и процессору не придется дожидаться ее загрузки
		__prefetchnta((char *)((char *)p + a + STEP_SIZE*6));

		// выполняем некоторые вычичисления
		x += a/(a+1);

		// считываем очередную порцию ячеек
		x += *(int *)((char *)p + a + 0);
		x += *(int *)((char *)p + a + 4);
		x += *(int *)((char *)p + a + 8);
		x += *(int *)((char *)p + a + 12);
		x += *(int *)((char *)p + a + 16);
		x += *(int *)((char *)p + a + 20);
		x += *(int *)((char *)p + a + 24);
		x += *(int *)((char *)p + a + 28);
	}
return x;
}


/*----------------------------------------------------------------------------
 *
 *						ТЕСТ C ПРЕДВЫБОРКОЙ prefetchnt0
 *								mem -> L2 -> L1
 *
----------------------------------------------------------------------------*/
int have_prefetcht0(int *p)
{
	int a;
	int x = 0;

	for(a = 0; a < BLOCK_SIZE; a += STEP_SIZE)
	{
		// даем команду на предвыборку следующей кэш-строки в L1/L2-кэш
		// она будет загружается параллельно с выполнением вычислений a/(a+1)
		// и, когда соотвествующая ячейка станет затребована, она уже
		// окажется в кэше и процессору не придется дожидаться ее загрузки
		_prefetcht0((char *)((char *) p + a + STEP_SIZE*6));

		// выполняем некоторые вычичисления
		x += a/(a+1);

		// считываем очередную порцию ячеек
		x += *(int *)((char *)p + a + 0);
		x += *(int *)((char *)p + a + 4);
		x += *(int *)((char *)p + a + 8);
		x += *(int *)((char *)p + a + 12);
		x += *(int *)((char *)p + a + 16);
		x += *(int *)((char *)p + a + 20);
		x += *(int *)((char *)p + a + 24);
		x += *(int *)((char *)p + a + 28);
	}
return x;
}

/*----------------------------------------------------------------------------
 *
 *						ТЕСТ C ПРЕДВЫБОРКОЙ prefetchnt1
 *								mem -> L2
 *
----------------------------------------------------------------------------*/
int have_prefetcht1(int *p)
{
	int a;
	int x = 0;

	for(a = 0; a < BLOCK_SIZE; a += STEP_SIZE)
	{
		// даем команду на предвыборку следующей кэш-строки в L2-кэш
		// она будет загружается параллельно с выполнением вычислений a/(a+1)
		// и, когда соотвествующая ячейка станет затребована, она уже
		// окажется в кэше и процессору не придется дожидаться ее загрузки
		_prefetcht1((char *)((char *)p + a + STEP_SIZE*6));

		// выполняем некоторые вычичисления
		x += a/(a+1);

		// считываем очередную порцию ячеек
		x += *(int *)((char *)p + a + 0);
		x += *(int *)((char *)p + a + 4);
		x += *(int *)((char *)p + a + 8);
		x += *(int *)((char *)p + a + 12);
		x += *(int *)((char *)p + a + 16);
		x += *(int *)((char *)p + a + 20);
		x += *(int *)((char *)p + a + 24);
		x += *(int *)((char *)p + a + 28);
	}
return x;
}



main()
{	
	int *p;

	PRINT("= = = memory optimization using prefetch = = =\n");
	PRINT_TITLE;

	// выделяем память
	p = malloc(BLOCK_SIZE);
	
	A_BEGIN(0)
		no_prefetch(p);
	A_END(0)

	A_BEGIN(1)
		have_prefetchnta(p);
	A_END(1)

	A_BEGIN(2)
		have_prefetcht0(p);
	A_END(2)

	A_BEGIN(3)
		have_prefetcht1(p);
	A_END(3)

	Lx_OUT("prefetchnta",Ax_GET(0),Ax_GET(1));
	Lx_OUT("prefetcht0 ",Ax_GET(0),Ax_GET(2));
	Lx_OUT("prefetcht1 ",Ax_GET(0),Ax_GET(3));


}



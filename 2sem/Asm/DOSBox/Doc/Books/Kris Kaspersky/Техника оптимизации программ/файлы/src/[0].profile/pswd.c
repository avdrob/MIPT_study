/*----------------------------------------------------------------------------
 *
 *				ПРИМЕР, ДЕМОНСТРИРУЮЩИЙ ТЕХНИКУ ОПТИМИЗАЦИИ
 *			и профилировку с помощью профилировщика Intel VTune
 *			====================================================
 *
 * Build 0x001 12.08.2002
----------------------------------------------------------------------------*/
// Это пример того, как не нужно писать программы! Здесь допущено  множество
// ошибок, снижающих производительность. Профилировка позволяет найти их все
// --------------------------------------------------------------------------

// КОНФИГУРАЦИЯ
#define ITER 100000						// макс. итераций
#define MAX_CRYPT_LEN	200				// макс. длина шифротекста

#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
//#include <memory.h>
#include <malloc.h>

/*----------------------------------------------------------------------------
 *
 *				процедура расшифровки шифротекста найденным паролем
 *				---------------------------------------------------
 *	ARG:
 *		pswd		:	пароль
 *		crypteddata	:	шифротекст
 *
 *	RET:
 *		*crypreddata:	расшифрованный шифротест
 *
 *	NOTE:
 *		none
-----------------------------------------------------------------------------*/
DeCrypt(char *pswd, char *crypteddata)
{
	unsigned int p = 0;	// указатель текущей позиции расшифровываемых данных

	// * * * ОСНОВНОЙ ЦИКЛ РАСШИФРОВКИ * * *
	do {
		// расшифровываем текущий символ
		crypteddata[p] ^= pswd[p % strlen(pswd)];
		// внимание: взятие остатка ^^^ _очень_ медленная операция
		// тем не менее здесь ей можно пользоваться  безбоязненно,
		// т.к. эта функция вызывается  крайне редко (если  вообще
		// вызывается

		// переходим к расшифровке следующего символа
	} while(++p < strlen(crypteddata));

	return 0;
}


/*----------------------------------------------------------------------------
 *
 *				процедура вычисления контрольной суммы пароля
 *				---------------------------------------------
 *	ARG:
 *		pswd		:	пароль
 *
 *	RET:			CRC данного пароля
 *
 *	NOTE:
 *		none
-----------------------------------------------------------------------------*/
int CalculateCRC(char *pswd)
{
	unsigned int a;
	int x = -1;			// ошибка вычисления CRC

	// алгоритм вычисления CRC, конечно, кривой как бумеранг, но ногами  чур
	// не   пинать,   -   это    делалось   исключительно  для  того,  чтобы
	// подемонстрировать missaling
	for (a = 0; a <= strlen(pswd);  a++)
				/* ^^^^^^^^^^^	хороший компилятор должен вынести этот вызов
								за пределы цикла, но на это полагаться ни  в
								коем случае нельзя, как мы дальше и убедимся
				*/
		x += *(int *)((int)pswd + a);
		/*	^^^^^^^^^ pswd должен быть выровнен! */

	return x;
}

/*----------------------------------------------------------------------------
 *
 *				процедура проверки контрольной суммы пароля
 *				---------------------------------------------
 *	ARG:
 *		pswd		:	пароль
 *		validCRC	:	истинное CRC
 *
 *	RET:			0	пароль не подходит
 *					!=0	validCRC
 *
 *	NOTE:
 *		none
---------------------------------------------------------------------------*/
int CheckCRC(char *pswd, int validCRC)
{
	if (CalculateCRC(pswd) == validCRC)
		return validCRC;
	// else
		return 0;
}


/*----------------------------------------------------------------------------
 *
 *				процедура обработки текущего пароля
 *				-----------------------------------
 *	ARG:
 *		crypteddata	:	зашифрованные данные, которые надо расшифровать
 *		pswd		:	пробный пароль
 *		validCRC	:	истинное CRC
 *		progress	:	процент уже перебранных паролей
 *
 *	RET:
 *		none
 *
 *	NOTE:
 *		функция do_pswd проверяет CRC тестируемого пароля и, если оно верно,
 * пытается расшифровать этим паролем шифротекст, выводя резултат расшифроки
 * на экран.
 *		так же выводится процент отбракованных паролей и текущий проверяемый
 * пароль; да! ногами не битт, это я умышленно показываю гонимый вариант!!!
-----------------------------------------------------------------------------*/
do_pswd(char *crypteddata, char *pswd, int validCRC, int progress)
{
	char *buff;

	// вывод текущего состояния на терминал
	printf("Current pswd : %10s [%d%%]\r",&pswd[0],progress);

	// проверка CRC пароля
	if (CheckCRC(pswd, validCRC))
	{								// <- CRC совпало

		// копируем шифроданные во временный буфер
		buff = (char *) malloc(strlen(crypteddata));
		strcpy(buff, crypteddata);

		// расшифровываем
		DeCrypt(pswd, buff);
	
		// выводим результат расшифровки на экран
		printf("CRC %8X: try to decrypt: \"%s\"\n",
											CheckCRC(pswd, validCRC),buff);
	}

	return 0;
}


/*----------------------------------------------------------------------------
 *
 *						процедура перебора паролей
 *						--------------------------
 *	ARG:
 *		crypteddata	:	зашифрованные данные, которые надо расшифровать
 *		pswd		:	пароль, с которого начинать перебор паролей
 *		max_iter	:	мак. кол-во генерируемых паролей
 *		validCRC	:	истинное CRC
 *
 *	RET:
 *		none
 *
 *	NOTE:
 *		функция do_pswd проверяет CRC тестируемого пароля и, если оно верно,
 * пытается расшифровать этим паролем шифротекст, выводя резултат расшифроки
 * на экран.
 *		так же выводится процент отбракованных паролей и текущий проверяемый
 * пароль; да! ногами не битт, это я умышленно показываю гонимый вариант!!!
-----------------------------------------------------------------------------*/
int gen_pswd(char *crypteddata, char *pswd, int max_iter, int validCRC)
{
	int a;
	int p = 0;

	// генерировать пароли
	for(a = 0; a < max_iter; a++)
	{
		// обработать текущий пароль
		do_pswd(crypteddata, pswd, validCRC, 100*a/max_iter);
		/*	внимание: деление  это очень медленная ^^^ операция и мы  поимем
			большие тормоза с ней!	*/

		// * основной цикл генерации паролей *
		// по алгоритму "защелка" или "счетчик"
		while((++pswd[p])>'z') 
		{	/* ^^^^ -	увеличиваем первый  справа символ  на  один */
			/*			если он переваливает за 'z' - входим в цикл */
			/*			собственно, этот цикл нужен для того, чтобы */
			/*			отреагировать на переваливание след. симв.  */

			// переваливщий за 'z' символ - в начальное состояние
			pswd[p] = '!';
			
			// следующий символ
			p++; if (!pswd[p])
			{					// <--	особая обработка  следующего символа
								//		если он равен нулю т.е. конец строки
								//		мы   расширяем  увеличивваем  строку

			pswd[p]=' ';		//		внимание! иницилизация на MIN_CHAR-1
								//		т.к. он увеличивается в цикле while!

			pswd[p+1]=0;		//		новый конец строки!
			}
		} // end while(pswd)

		// возвращаем указатель на место
		p = 0;
	} // end for(a)

	return 0;
}

/*----------------------------------------------------------------------------
 *
 *				Функциия выводит число, разделяя разряды точками
 *				------------------------------------------------
 *	ARG:
 *		per			:	число для вывода
 *
 *	RET:
 *		none
 *
 *	NOTE:
 *		функция выводит на экран число, усекая его до целой части
 *
-----------------------------------------------------------------------------*/
print_dot(float per)
{
	// * * * КОНФИГУРАЦИЯ * * *
	#define N			3		// отделять по три разряда
								// при выводе HEX надо отделть два

	#define DOT_SIZE	1		// размер точки-разделителя

	#define	DOT			"."		// разделитель
	
	int		a;
	char	buff[666];

	sprintf(buff,"%0.0f", per);
	/* ^^^^^^^^^^^^^^^^ формат вывода */

	// * * * цикл рабора числа по рязрядам * * *
	for(a = strlen(buff) - N; a > 0; a -= N)		// <-- смещаем
	{ /* ^^^^^^^^^^^^^^^^ - это глупый код, - не вызывайте функцию часто */

			memmove(buff + a + DOT_SIZE, buff + a, 66);
			/* внимание!						^^^^^^^^^ */

			if(buff[a]==' ') break;	// достигнут пробел - конец работы
				else
			// копируем разделитель
			memcpy(buff + a, DOT, DOT_SIZE);
	}
	// выводиим на экран
	printf("%s\n",buff);

	return 0;
}


main(int argc, char **argv)
{
	// переменные
	FILE *f;				// для чтения исходного файла (если есть)
	char *buff;				// для чтения данных исходного файла
	char *pswd;				// текущий тестируемый пароль (need by gen_pswd)
	int validCRC;			// для хранения оригинального CRC пароля
	unsigned int t;			// для замера времени исполнения перебора
	int iter = ITER;		// макс. кол-во перебираемых паролей
	char *crypteddata;		// для хранения шифрованных

	//	build-in default crypt
	//	кто прочтет, что здесь  зашифровано, тот  постигет  Великую  Тайну
	//	Крис Касперски ;)
	char _DATA_[] = "\x4B\x72\x69\x73\x20\x4B\x61\x73\x70\x65\x72\x73\x6B"\
					"\x79\x20\x44\x65\x6D\x6F\x20\x43\x72\x79\x70\x74\x3A"\
					"\xB9\x50\xE7\x73\x20\x39\x3D\x30\x4B\x42\x53\x3E\x22"\
					"\x27\x32\x53\x56\x49\x3F\x3C\x3D\x2C\x73\x73\x0D\x0A";

	// TITLE
	printf("= = = VTune profiling demo = = =\n==================================\n");

	// HELP
	if (argc==2)
	{
			printf("USAGE:\n\tpswd.exe [StartPassword MAX_ITER]\n");
			return 0;
	}
	
	// выделение памяти
	printf("memory malloc\t\t");
	buff = (char *) malloc(MAX_CRYPT_LEN);
	if (buff) printf("+OK\n"); else {printf("-ERR\n"); return -1;}

	// получение шифротекста для расшифровки
	printf("get source from\t\t");
	if ((f=fopen("crypted.dat","r"))!=0)
	{
		printf("crypted.dat\n");
		fgets(buff,MAX_CRYPT_LEN, f);
	}
	else
	{
		printf("build-in data\n");
		buff=_DATA_;
	}

	// выделение CRC
	validCRC=*(int *)((int) strstr(buff,":")+1);
	printf("calculate CRC\t\t%X\n",validCRC);
	if (!validCRC)
	{
		printf("-ERR: CRC is invalid\n");
		return -1;
	}

	// выделение шифрованных данных
	crypteddata=strstr(buff,":") + 5;
	//printf("cryptodata\t\t%s\n",crypteddata);

	// выделение памяти для парольного буфера 
	printf("memory malloc\t\t");
	pswd = (char *) malloc(512*1024); pswd+=62;
		/*	демонстрация последствий ^^^^^^^^^^^ невыровненных  данных  */
		/*	размер блока объясняется тем, что при запросе таких блоков  */
		/*	malloc всегда выравнивает адрес на 64 Кб, что нам и надо	*/

	memset(pswd,0,666);		// <-- иницилизация 

	if (pswd) printf("+OK\n"); else {printf("-ERR\n"); return -1;}
	
	// разбор аргмуентов командной строки
	// получение стартового пароля и макс. кол-ва итераций
	printf("get arg from\t\t");
	if (argc>2)
	{
		printf("command line\n");
		if(atol(argv[2])>0) iter=atol(argv[2]);
		strcpy(pswd,argv[1]);
	}
		else
	{
		printf("build-in default\n");
		strcpy(pswd,"!");
	}
	printf("start password\t\t%s\nmax iter\t\t%d\n",pswd,iter);
	

	// начало перебора паролей
	printf("==================================\ntry search... wait!\n");
	t=clock();
		gen_pswd(crypteddata,pswd,iter,validCRC);
	t=clock()-t;

	// вывод кол-ва перебираемых паролей за сек
	printf("                                       \rPassword per sec:\t");
	print_dot(iter/(float)t*CLOCKS_PER_SEC);

	return 0;
}
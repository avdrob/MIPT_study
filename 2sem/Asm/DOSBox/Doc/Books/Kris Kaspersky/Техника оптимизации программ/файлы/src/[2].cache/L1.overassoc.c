/*----------------------------------------------------------------------------
 *
 *				ѕ–»ћ≈– ƒ≈ћќЌ—“–»–”ёў»… ѕјƒ≈Ќ»≈ ѕ–ќ»«¬ќƒ»“≈Ћ№Ќќ—“»
 *			при попадении обрабатываемых данных в одну и ту же кэш-линейку
 *			==============================================================
 *
 * Build 0x001 06.08.2002
----------------------------------------------------------------------------*/
//  ќЌ‘»√”–ј÷»я
#define N_ITER			466			// кол-во итераций
									// теоритически бует востребовано
									// LINE_SIZE*N_ITER байт кэш-пам€ти,
									// т.е. в данном случае 466*64 = ~30 Kb

#define CACHE_BANK_SIZE	(4*K)		// размер кэш-банка

#define LINE_SIZE		64			// максимально возможный размер кэш-линий

#define BLOCK_SIZE		((CACHE_BANK_SIZE+LINE_SIZE)*N_ITER) // размер бурка

#include <DoCPU.h>					// подключаем профайлер


//----------------------------------------------------------------------------
//
//					¬ј–»јЌ“, »ЋЋё—“–»–”ёў»…  ќЌ‘Ћ» “џ  ЁЎ-Ћ»Ќ»…
//
//----------------------------------------------------------------------------
int over_assoc(int *p)
{
	int a;
	volatile int x=0;

	// внимание: top-level цикл поскипан, поскольку профайлер
	// и без того прокрутит этот цикл 10 раз
	for(a=0; a < N_ITER; a++)
		// читаем пам€ть с шагом 4 Kb, в результате
		// и  на  P-II/P-III/P-4  и  на  AMD Athlon
		// быстро  наступает  насыщение кэша и идет
		// его перегруз;
		// поскольку, обрабатываетс€ более 12 €чеек
		// буферизаци€  чтени€ на Athlon nположени€
		// уже не спасает
		//x+=*(int *)((int)p + a*CACHE_BANK_SIZE);
		*(int *)((char *)p + a*CACHE_BANK_SIZE)=x;

	return x;
}

//----------------------------------------------------------------------------
//
//					¬ј–»јЌ“, »—ѕќЋЌяёў»…—я Ѕ≈«  ќЌ‘Ћ» “ќ¬
//
//----------------------------------------------------------------------------
int optimize(int  *p)
{
	int a=0;
	volatile int x=0;

	// внимание: top-level цикл поскипан, поскольку профайлер
	// и без того прокрутит этот цикл 10 раз
	for(a=0; a < N_ITER; a++)
	{
		// читаем па€ть  с  шагом  CACHE_BANK_SIZE+LINE_SIZE
		// т.е. в данном случае 4096+64=4160 байт;
		// поскольку установочные адреса всех €чеек различны
		// мы  не  имеем  конфликтов  и  использует  емкость
		// кэш-пам€т на все 100%
		//x+=*(int *)((int)p + a*(CACHE_BANK_SIZE+LINE_SIZE));
		*(int *)((char *)p + a*(CACHE_BANK_SIZE+LINE_SIZE))=x;
	}
	return x;
}


main()
{
	int *p;
	int a = 0;

	PRINT("= = = демонстраци€ конфликта кэш-линеек = = =\n");
	PRINT_TITLE;

	// выдел€ем пам€ть
	p = (int *)_malloc32(BLOCK_SIZE);

	// пессимизированный вариант
	A_BEGIN(0)
		a+=over_assoc(p);
	A_END(0)

	// оптимизированный вариант
	A_BEGIN(1)
		a+=optimize(p);
	A_END(1)

	// вывод результатов на экран
	Lx_OUT("",Ax_GET(1),Ax_GET(0));

}

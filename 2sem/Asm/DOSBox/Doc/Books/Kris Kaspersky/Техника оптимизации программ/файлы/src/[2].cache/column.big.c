/*----------------------------------------------------------------------------
 *
 *						ѕ–»ћ≈– ƒ≈ћќЌ—“–»–”ёў»… Ё‘‘≈ “»¬Ќќ—“№
 *					ќЅ–јЅќ“ »	ЅќЋ№Ў»’		ƒ¬”ћ≈–Ќџ’	ћј——»¬ќ¬
 *					============================================
 *
 * Build 0x001 07.08.2002
----------------------------------------------------------------------------*/
//#define __OPTIMIZE__			// раскомментрируйте это дл€ оптимизированной
								// обработки массива по строкам
#ifdef __OPTIMIZE__
	#define N_COL				(512+16)	// оптимальное кол. строк  матрицы
											// поскольку оно не кратно размеру
											// кэш-банка  и  кэш  используетс€
											// полностью
#else
	#define N_COL				(512)		//  неоптимальное колю строк матр.
											// поскольку  оно  кратно  размеру
											// кэш-банка  и  кэш  используетс€
											// _не_ полностью
#endif

#define N_ROW					(512)

#include <DoCPU.h>

/*----------------------------------------------------------------------------
 *
 *				ѕќ—Ћ≈ƒќ¬ј“≈Ћ№Ќјя ќЅ–јЅќ“ ј ћј——»¬ј ѕќ —“ќЋЅ÷јћ
 *
----------------------------------------------------------------------------*/
int FOR_COL(int (*foo)[N_COL])
{
	int	x, y;
	int	z = 0;

	for (x = 0; x < N_ROW; x++)
	{
		for (y = 0; y < N_COL; y++)
			z += foo[x][y];
	}
	return z;
}


/*----------------------------------------------------------------------------
 *
 *				ѕќ—Ћ≈ƒќ¬ј“≈Ћ№Ќјя ќЅ–јЅќ“ ј ћј——»¬ј ѕќ —“–ќ јћ
 *
----------------------------------------------------------------------------*/
int FOR_ROW(int (*foo)[N_COL])
{
	int	x, y;
	int	z = 0;

	for (x = 0; x < N_COL; x++)
	{
		// внимание: если высота матрицы кратна  размеру  кэш-банка, то
		// вследствии ограниченной ассоацитивности кэша его эффективна€
		// емкость значительно  снизитс€ и кэш-пам€ти  может  по просту
		// не хватить, что приведет к посто€нным промахам!
		for (y = 0; y < N_ROW; y++)
			z += foo[y][x];
	}
	return z;
}

#define _CACHE_SIZE	(64*K)
#define _LINE_SIZE	(32)


/*----------------------------------------------------------------------------
 *
 *				ѕј–јЋЋ≈Ћ№Ќя ќЅ–јЅќ“ ј ћј——»¬ј ѕќ —“ќЋЅ÷јћ
 *
----------------------------------------------------------------------------*/
int FOR_32(int (*foo)[N_COL])
{
	int x, y;
	int k, w;
	int z = 0;

	// перебираем строки одну за другой
	for (x = 0; x < N_ROW; x++)
	{
		// обрабатываем очередной столбец...
		for (k = 0; k < N_COL; k += (_CACHE_SIZE/sizeof(int)))
		{	//... причем ,обрабатываем его кусками, полностью вмещающимис€
			// в кэш первого уровн€ (на P-III и особенно P-4 - второго уровн€)

			// иницируем паралельную загрузку данных в кэш
			for (y = k; (y < k + (_CACHE_SIZE/sizeof(int))) && (y < N_COL);  y+=(_LINE_SIZE/sizeof(int)));
			{
				z += foo[x][y];
			}
			
			// читаем данные, уже загруженные в кэш
			for (y = k; y < k + (_CACHE_SIZE/sizeof(int)) && (y < N_COL);  y+=(_LINE_SIZE/sizeof(int)))
			{
				for (w = y + 1; w < (y + 8); w++)
					z += foo[x][w];
			}
			
		}
	}

	return z;
}



main()
{

	int	z = 0;

	// выдел€ем пам€ть дл€ 2D-массива
	int (*foo)[N_COL] = (int (*)[N_COL]) malloc(N_COL*N_ROW*sizeof(int));
	
	// TITLE
	PRINT("= = = особенности обработки больших двумерных массивов = = =\n");
	PRINT_TITLE;

	// обработка по столбцам
	A_BEGIN(0)
		FOR_COL(foo);
	A_END(0)

	// обработка по строкам
	A_BEGIN(1)
		FOR_ROW(foo);
	A_END(1)

	A_BEGIN(2)
		FOR_32(foo);
	A_END(2)

	// вывод результатов замеров на экран
	Lx_OUT("SERAL	 COL vs SERIAL ROW",	Ax_GET(0), Ax_GET(1));
	Lx_OUT("PARALLEL COL vs SERIAL COL",	Ax_GET(0), Ax_GET(2));

	return z;
}

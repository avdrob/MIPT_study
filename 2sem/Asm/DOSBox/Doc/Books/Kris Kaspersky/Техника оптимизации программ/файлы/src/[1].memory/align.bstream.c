/* ---------------------------------------------------------------------------
 * @
 *				”“»Ћ»“ј ƒ≈ћќЌ—“–»–”ёўјя Ё‘‘≈ “»¬Ќќ—“№
 *			¬џ–ј¬Ќ»¬јЌ»я	Ѕј…“ќ¬џ’	ѕќ“ќ ќ¬		ƒјЌЌџ’
 *			==============================================
 *
 * Build 0x001 05.07.2002
--------------------------------------------------------------------------- */
// конфигураци€
#define BLOCK_SIZE (4*M)

// кол-во итераций
#define N (BLOCK_SIZE/sizeof(int))


#include <DoCPU.h>

// -[Simple byte-crypt]-------------------------------------------------------
//
//	ARG:
//		src		- указатель на шифруемый блок
//		mask	- маска шифровани€ (байт)
//
//	README:
//		дл€ достижени€ наибольшей производительности, шифруемый блок должен
// быть выровнен по границе 4 байт
//----------------------------------------------------------------------------
void unalign_crypt(char *src, int n, int mask)
{
	int a;
	int supra_mask;

	// размножаем байтовую маску дл€ получени€ двойного слова	
	supra_mask = mask+(mask<<8)+(mask<<16)+(mask<<24);
	
	// обрабатываем байты двойными словами
	for (a = 0; a < n; a += 4)
	{
		 *(int *)src ^= supra_mask;  src+=4;
	}

	// обрабатываем оставшийс€ "хвост" (если он есть)
	for (a = (n & ~3); a < n; a++)
	{
		 *src ^= mask;	 src += 1;
	}

}

// -[Simple byte-crypt]-------------------------------------------------------
//
//	ARG:
//		src		- указатель на шифруемый блок
//		mask	- маска шифровани€ (байт)
//
//	DEPENCE:
//		unalign_crypt
//
//	README:
//		функци€ самосто€тльно выравнивает шифруемые данные
//----------------------------------------------------------------------------
void align_crypt(char *src, int n, int mask)
{
	int n_ualign;
	
	// выичисл€ем величину на которую следует "догнать" блок
	// чтобы он стал выровненным блоком
	n_ualign= 32 - ((int) src & 15);

	// шифруем пока не достигнем границы пакетного цикла обмена
	unalign_crypt(src, n_ualign, mask);

	// смело шифруем все остальное
	// т.к. src+n_ualign - гарантированно выровненный указатель!
	unalign_crypt(src+n_ualign, n-n_ualign, mask);
	/* не забываем уменьшить   ^^^^^^^^^^^^ ко-во шифруемых байтов */
}


main()
{
	char *p;
	
	// TITLE
	PRINT("= = = демонстраци€ эффективности выравнивани€ байтовых блоков = = =\n");
	PRINT_TITLE;

	// выдел€ем пам€ть
	p=malloc(BLOCK_SIZE);


	/* -----------------------------------------------------------------------
	 *
	 *					обработка выровненного блока
	 *
	----------------------------------------------------------------------- */
	VVV;
	A_BEGIN(0)
		unalign_crypt(p, BLOCK_SIZE, 0x66);
	A_END(0)


	/* -----------------------------------------------------------------------
	 *
	 *					обработка невыровненного блока
	 *
	----------------------------------------------------------------------- */
	VVV;
	// "уналиджим" указатель
	p=p + 1;

	A_BEGIN(1)
		unalign_crypt(p , BLOCK_SIZE, 0x66);
	A_END(1)

	/* -----------------------------------------------------------------------
	 *
	 *					автоматическое выравнивание
	 *
	----------------------------------------------------------------------- */
	VVV;
	A_BEGIN(2)
		align_crypt(p, BLOCK_SIZE, 0x66);
	A_END(2)

	// вывод результатов на консоль
	Lx_OUT("unalign...",Ax_GET(0),Ax_GET(1));
	Lx_OUT("auto align",Ax_GET(0),Ax_GET(2));
	return 0;
}


void _P_S()
{
/*
	....в смертный час нет одиночества
			јнтуан де —ент-Ёкзюпери. ÷итадель
*/
}



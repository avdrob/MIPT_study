/* ---------------------------------------------------------------------------
 *
 *			ИЗМЕРЕНИЕ СКОРОСТИ ИНИЦИЛИЗАЦИИ ПАМЯТИ В ОБОИХ НАПРАВЛЕНИЯХ
 *			===========================================================
 *
 * Build 0x001 26.08.2002
--------------------------------------------------------------------------- */

#include <DoCPU.h>

#define _PAGE_SIZE (4*K)				// размер одной страницы памяти
#define BLOCK_SIZE (4*M)				// размер обрабатываемого блока


/* ---------------------------------------------------------------------------

								ИНИЦИЛИЗАЦИЯ /---->

--------------------------------------------------------------------------- */
l_to_r(char *p)
{
			memset(p,0x66,BLOCK_SIZE);			// иницилизиуем память
			A_READ(p,BLOCK_SIZE);				// имитируем обработку блока
}


/* ---------------------------------------------------------------------------

							ИНИЦИЛИЗАЦИЯ <-------/

--------------------------------------------------------------------------- */
r_to_l(char *p)
{
	char *p2;
	p2 = p;
	__asm{								// реализуем обратное копирование на асме
			STD							// устанавливаем флаг обратного направления
			MOV	EDI,[p2]				// в рег. EDI заносим указатель на иницилизируемый блок
			MOV	ECX,BLOCK_SIZE/4		// в рег. ECX заносим количество двойных слов для записи
			REP	STOSD					// иницилизируем память случайным значением, оказавшися в EAX
			MOV	[p2],EDI				// обновляем содержимое указателя
			CLD							// восстаналиваем флаг направления (этого требуют библиотечные фукнции Си)
	}
	A_READ(p2, BLOCK_SIZE);				// имитируем обработку блока
}


/* ---------------------------------------------------------------------------

						ОПТИМИЗИРОВАННЫЙ ВАРИАНТ

--------------------------------------------------------------------------- */
optimize(char *p)
{
	int a, b, c;

	b = BLOCK_SIZE;						// заносим в b размер иницилизируемого блока
	c = _PAGE_SIZE;						// заносим в c размер "нарезания" памяти
	while(b)							// иницилизируем, пока не проиницилизируем все
	{
		if (b < c) c = b;				// если оставшийся хвост по размеру меньше страницы,
										// корректируем размер иницилизируемого остатка
			p -= c;							// корректирует указатель
			memset(p, 0x66, c);				// иницилизирует
			b -= c;							// уменьшаем размер блока на величину нарезания
	}
	A_READ(p, BLOCK_SIZE);				// имитируем обработку
}


main()
{
	int b,c;
	char *p1,*p2,*p3;

	// выделяем память
	p1 = (char *) _malloc32(BLOCK_SIZE);
	p2 = (char *) _malloc32(BLOCK_SIZE);
	p3 = (char *) _malloc32(BLOCK_SIZE);

	// устанавливаем указатели на конец (память будет иницилизироваться назад)
	p2 += BLOCK_SIZE;
	p3 += BLOCK_SIZE;

	PRINT("= == memset direct test = = =\n");
	PRINT_TITLE;
	
	A_BEGIN(0)
		l_to_r(p1);
	A_END(0)

	A_BEGIN(1)
		r_to_l(p2);
	A_END(1)

	A_BEGIN(2)
		optimize(p3);
	A_END(2)


	Ax_OUT("<--", 0, 1);							// вывод <-- (первый замер - базовый)
	Ax_OUT("<->", 0, 2);							// вывод <-->
	return 0;
}




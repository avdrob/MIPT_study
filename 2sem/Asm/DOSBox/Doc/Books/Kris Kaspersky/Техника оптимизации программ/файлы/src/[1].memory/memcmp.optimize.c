/* ---------------------------------------------------------------------
 * @
 *						ОПТИМИЗАЦИЯ MEMCMP
 *						==================
 *
 * Build 0x001	09.06.2002
------------------------------------------------------------------------ */
// конфигурация
#define BLOCK_SIZE		(4*M)			// объем обрабатываемого блока
#define DRAM_PG_SIZE	(4*K)			// длина DRAM-страницы
#define BRUST_LEN		(32)			// длина пакетного цикла обмена


#include <DoCPU.h>
main()
{
	char *p1, *p2;
	int a, b, x = 0;	
	unsigned int crc_1,crc_2;

	// TITLE
	PRINT("=== оптимизация функции memcmp ===\n");
	PRINT_TITLE;

	// выделяем память
	p1 = (char *) _malloc32(BLOCK_SIZE);
	p2 = (char *) _malloc32(BLOCK_SIZE+DRAM_PG_SIZE);

	// зануляем оба региона (чтобы было что с чем сравнивать)
	memset(p1, 0, BLOCK_SIZE);
	memset(p2, 0, BLOCK_SIZE + DRAM_PG_SIZE);

	// добиваемся чтобы блоки отличались в последнем байте
	p1[BLOCK_SIZE-1] = 66;
	p2[BLOCK_SIZE-1] = 99;

	/* ----------------------------------------------------------------------
	 *
	 *						ШТАТНАЯ ФУНКЦИЯ memcmp
	 *
	 * ------------------------------------------------------------------- */
	CLEAR_L2_CACHE();VVV;
	A_BEGIN(0)
		x += memcmp(p1, p2, BLOCK_SIZE);
	A_END(0)

	/* ----------------------------------------------------------------------
	 *
	 *						ШТАТНАЯ ФУНКЦИЯ memcmp
	 *					с чередованием   DRAM-банков
	 *
	 * ------------------------------------------------------------------- */
	CLEAR_L2_CACHE();VVV;
	A_BEGIN(1)
		x += memcmp(p1, p2 + DRAM_PG_SIZE, BLOCK_SIZE);
	A_END(1)

	/* ----------------------------------------------------------------------
	 *
	 *				СРАВНЕНИЕ ДВОЙНЫМИ СЛОВАМИ БЕЗ ЧЕРЕДОВАНИЯ
	 *
	 * ------------------------------------------------------------------- */
	CLEAR_L2_CACHE();VVV;
	A_BEGIN(2)
		a = 0;
		while(a<BLOCK_SIZE)
		{
			if (*(int*)((int)p1+a)!= *(int*)((int)p2+a)) break;
														/* difference */
			a+=sizeof(int);
		}
	A_END(2)


	/* ----------------------------------------------------------------------
	 *
	 *					СРАВНЕНИЕ ДВОЙНЫМИ СЛОВАМИ
	 *			С ОПТИМИАЛЬНЫМ ЧЕРЕДОВАНИЕМ DRAM-банков
	 *
	 * ------------------------------------------------------------------- */
	CLEAR_L2_CACHE();VVV;
	A_BEGIN(3)
		a=0;
		while(a < BLOCK_SIZE)
		{
			if (*(int*)((int)p1+a) != *(int*)((int)p2+a+DRAM_PG_SIZE)) break;
															/* difference */
			a += sizeof(int);
		}
	A_END(3)


	/* ----------------------------------------------------------------------
	 *
	 *							ХЕШ-СРАВНЕНИЕ
	 *
	 * ------------------------------------------------------------------- */
	CLEAR_L2_CACHE();VVV;
	A_BEGIN(4)
		for(a = 0;a < BLOCK_SIZE; a += DRAM_PG_SIZE)
		{
			crc_1 = 0; crc_2 = 0;

			// подсчет CRC очередного блока по указателю p1
			for(b = 0; b < DRAM_PG_SIZE; b += sizeof(int))
				// внимание! это очень слабый алгоритм подсчета CRC
				// и его можно использовать _только_ для демонстрации
				crc_1 += *(int*)((int)p1+a+b);
				
			// подсчет CRC очередного блока по указателю p2
			for(b = 0; b < DRAM_PG_SIZE; b += sizeof(int))
				crc_2 += *(int*)((int)p2+a+b);
		
			if (crc_1 != crc_2)
				break;	// если CRC не совпадают, следовательно,
						// блоки памяти различны.
						// при необходимости можно вызвать
						// memcmp(p1+a, p2+a, BLOCK_SIZE-a)
						// для уточнения результата
		}
	A_END(4)


	/* ----------------------------------------------------------------------
	 *
	 *							ХЕШ-СРАВНЕНИЕ
	 *			С ОПТИМИАЛЬНЫМ ЧЕРЕДОВАНИЕМ DRAM-банков
	 *
	 * ------------------------------------------------------------------- */
	CLEAR_L2_CACHE();VVV;
	A_BEGIN(5)
		for(a = 0; a < BLOCK_SIZE; a += BRUST_LEN)
		{
			crc_1 = 0; crc_2 = 0; b = 0;

			// подсчет CRC очередного блока по указателю p2
			for(b = 0; b < BRUST_LEN; b += sizeof(int))
				crc_1 += *(int*)((int)p1+a+b);
		
			// подсчет CRC очередного блока по указателю p2
			for(b = 0; b < BRUST_LEN; b += sizeof(int))
				crc_1 += *(int*)((int)p2+a+b +DRAM_PG_SIZE /* <-- */);

			if (crc_1 != crc_2)
			{
				//printf("Opa!\n");
				break;	// Если CRC не совпадают, следовательно,
						// блоки памяти различны.
						// При необходимости можно вызвать
						// memcmp(p1+a, p2+a, BLOCK_SIZE-a)
						// для уточнения результата
			}
		}
	A_END(5)

	// вывод результатов
	printf("memcmp......................... %d", Ax_GET(0)); L1_OUT("");
	printf("memcmp with DRAM-interleaving.. %d", Ax_GET(1)); Lx_OUT("",Ax_GET(0),Ax_GET(1));
	printf("DWORD compare.................. %d", Ax_GET(2)); Lx_OUT("",Ax_GET(0),Ax_GET(2));
	printf("DWORD compare with interleaving %d", Ax_GET(3)); Lx_OUT("",Ax_GET(0),Ax_GET(3));
	printf("Hash-compare................... %d", Ax_GET(4)); Lx_OUT("",Ax_GET(0),Ax_GET(4));
	printf("Hash-compare with interleaving. %d", Ax_GET(5)); Lx_OUT("",Ax_GET(0),Ax_GET(5));

	return x+crc_1+crc_2;
}

_P_S()
{
/*
	"...даже   жизнь   они   поделили   на  две  части, и обе эти части лишены
	всякого   смысла:    сперва   они   достигают,  потом  хотят  наслаждаться
	достигнутым.  Все  видели,   как   растет  дерево.  Но  когда оно выросло,
	видел  ли  кто-нибудь,  чтобы   оно   наслаждалось  своими плодами? Дерево
	растет и растет. Запомни: завоеватель,    превратившийся    в   обывателя,
	погиб..."
										Антуан   де Сент-Экзюпери. Цитадель
*/
}
